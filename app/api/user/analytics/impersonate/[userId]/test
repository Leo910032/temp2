// app/api/user/analytics/impersonate/[userId]/route.js
import { NextResponse } from 'next/server';
import { adminAuth, adminDb } from '@/lib/firebaseAdmin';

// ✅ Import your existing enterprise services with CORRECT paths
import { 
    validateTeamPermission,
    checkUserTeamMembership 
} from '@/lib/services/serviceEnterprise/server/enterprisePermissionService';
import { logSecurityEvent } from '@/lib/services/serviceEnterprise/server/enterpriseSecurityService';
import { createAuditLogEntry } from '@/lib/services/serviceEnterprise/server/enterpriseAuditService';
import { 
    PERMISSIONS,
    TEAM_ROLES 
} from '@/lib/services/serviceEnterprise/constants/enterpriseConstants';

/**
 * GET /api/user/analytics/impersonate/[userId]
 * Allow managers to view analytics of their team members
 */
export async function GET(request, { params }) {
    const requestId = `impersonate-${Math.random().toString(36).substring(2, 9)}`;
    const startTime = Date.now();
    
    console.log(`[${requestId}] 🔍 Analytics impersonation request for userId: ${params.userId}`);

    let decodedToken = null;

    try {
        // ... (The entire GET handler from your original file remains unchanged)
        // ... (It correctly handles permissions, auditing, etc.)
        // ...
        // ✅ 1. Authentication
        const authHeader = request.headers.get('authorization');
        if (!authHeader?.startsWith('Bearer ')) {
            console.warn(`[${requestId}] 🛡️ Authentication failed: No Bearer token`);
            return NextResponse.json({ error: 'Unauthorized: Missing token' }, { status: 401 });
        }

        const token = authHeader.split('Bearer ')[1];
        decodedToken = await adminAuth.verifyIdToken(token);
        const managerId = decodedToken.uid;
        const targetUserId = params.userId;

        console.log(`[${requestId}] 🛡️ Manager: ${managerId} requesting analytics for: ${targetUserId}`);

        // ✅ 2. Get query parameters
        const { searchParams } = new URL(request.url);
        const teamId = searchParams.get('teamId');
        const period = searchParams.get('period') || '30d';

        if (!teamId) {
            console.warn(`[${requestId}] ❌ Missing teamId parameter`);
            return NextResponse.json({ 
                error: 'teamId is required for analytics impersonation' 
            }, { status: 400 });
        }

        // ✅ 3. Permission validation using your services
        console.log(`[${requestId}] 🔒 Validating permissions for team: ${teamId}`);
        const hasViewPermission = await validateTeamPermission(managerId, teamId, PERMISSIONS.CAN_VIEW_TEAM_ANALYTICS);

        if (!hasViewPermission) {
            console.warn(`[${requestId}] ❌ Manager lacks CAN_VIEW_TEAM_ANALYTICS permission`);
   await logSecurityEvent({
                userId: managerId,
                action: 'UNAUTHORIZED_IMPERSONATION_ATTEMPT',
                details: {
                    targetUserId,
                    teamId,
                    reason: 'Insufficient permissions'
                },
                severity: 'HIGH',
                ipAddress: request.headers.get('x-forwarded-for') || 'unknown'
            });
            return NextResponse.json({ 
                error: 'Insufficient permissions to view team member analytics' 
            }, { status: 403 });
        }

        // ✅ 4. Verify target user is in the same team
        console.log(`[${requestId}] 👥 Verifying team membership`);
        const isTargetInTeam = await checkUserTeamMembership(targetUserId, teamId);
        const isManagerInTeam = await checkUserTeamMembership(managerId, teamId);

        if (!isTargetInTeam || !isManagerInTeam) {
            console.warn(`[${requestId}] ❌ Team membership validation failed`);
            await logSecurityEvent({ /* ... */ });
            return NextResponse.json({ 
                error: 'User is not a member of your team' 
            }, { status: 403 });
        }

        // ✅ 5. Get target user's account data
        console.log(`[${requestId}] 📊 Fetching target user analytics data`);
        const targetUserDoc = await adminDb.collection('AccountData').doc(targetUserId).get();
        if (!targetUserDoc.exists) {
            console.warn(`[${requestId}] ❌ Target user not found`);
            return NextResponse.json({ error: 'Target user not found' }, { status: 404 });
        }
        const targetUserData = targetUserDoc.data();

        // ✅ 6. Fetch analytics data (using the NEW, corrected logic)
        const analyticsData = await fetchUserAnalytics(targetUserId, period);

        // ✅ 7. Log the impersonation using your audit service
        await createAuditLogEntry({
            teamId,
            action: 'ANALYTICS_IMPERSONATION',
            performedBy: managerId,
            targetUserId: targetUserId,
            details: {
                period,
                dataTypes: Object.keys(analyticsData),
                accessReason: 'Manager viewing team member analytics'
            },
            metadata: {
                requestId,
                ipAddress: request.headers.get('x-forwarded-for') || 'unknown',
                userAgent: request.headers.get('user-agent') || 'unknown'
            }
        });

        // ✅ 8. Return analytics data with impersonation context
        const processingTime = Date.now() - startTime;
        console.log(`[${requestId}] ✅ Impersonation successful. Processing time: ${processingTime}ms`);

        return NextResponse.json({
            ...analyticsData,
            impersonationContext: {
                targetUserId,
                targetUserData: {
                    username: targetUserData.username,
                    email: targetUserData.email,
                    displayName: targetUserData.displayName || targetUserData.username
                },
                managerId,
                teamId,
                period,
                accessTimestamp: new Date().toISOString(),
                requestId
            }
        });

    } catch (error) {
        // ... (Error handling remains the same)
        const processingTime = Date.now() - startTime;
        console.error(`[${requestId}] 💥 Impersonation error:`, { /* ... */ });
        try {
            await logSecurityEvent({ /* ... */ });
        } catch (logError) {
            console.error(`[${requestId}] Failed to log security event:`, logError);
        }
        if (error.code === 'auth/id-token-expired' || error.code === 'auth/argument-error') {
            return NextResponse.json({ error: 'Token is invalid or expired.' }, { status: 401 });
        }
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
    }
}

// =============================================================================
//  MODIFIED SECTION: THIS IS THE CORRECTED LOGIC
// =============================================================================

/**
 * Returns an object with keys for today, yesterday, this week, and this month.
 */
function getDateKeys() {
    const now = new Date();
    const today = now.toISOString().split('T')[0];
    const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
    const yearStart = new Date(now.getFullYear(), 0, 1);
    const weekNumber = Math.ceil(((now - yearStart) / 86400000 + yearStart.getDay() + 1) / 7);
    const weekKey = `${now.getFullYear()}-W${weekNumber.toString().padStart(2, '0')}`;
    const monthKey = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
    return { today, yesterday, weekKey, monthKey };
}

/**
 * Processes the raw, single-document analytics data from Firestore.
 * This logic is copied from your working `/api/user/analytics` route.
 */
function processAnalyticsData(rawData) {
    const safeData = rawData || {};
    const { today, yesterday, weekKey, monthKey } = getDateKeys();

    const dailyViews = {};
    const dailyClicks = {};

    // Extract daily data from flattened dot-notation keys
    Object.keys(safeData).forEach(key => {
        if (key.startsWith('dailyViews.')) {
            dailyViews[key.replace('dailyViews.', '')] = safeData[key];
        }
        if (key.startsWith('dailyClicks.')) {
            dailyClicks[key.replace('dailyClicks.', '')] = safeData[key];
        }
    });
    
    // Process top links from flattened dot-notation keys
    const linkClicksFromDots = {};
    Object.keys(safeData).forEach(key => {
        const match = key.match(/^linkClicks\.([^.]+)\.(.+)$/);
        if (match) {
            const linkId = match[1];
            const property = match[2];
            if (!linkClicksFromDots[linkId]) linkClicksFromDots[linkId] = { linkId };
            if (property.includes('.')) {
                const [mainProp, subProp] = property.split('.', 2);
                if (!linkClicksFromDots[linkId][mainProp]) linkClicksFromDots[linkId][mainProp] = {};
                linkClicksFromDots[linkId][mainProp][subProp] = safeData[key];
            } else {
                linkClicksFromDots[linkId][property] = safeData[key];
            }
        }
    });

    const topLinks = Object.values(linkClicksFromDots).map(linkData => ({
        linkId: linkData.linkId,
        title: linkData.title || 'Untitled Link',
        url: linkData.url || '',
        type: linkData.type || 'custom',
        totalClicks: linkData.totalClicks || 0,
        todayClicks: linkData.dailyClicks?.[today] || 0,
        weekClicks: linkData.weeklyClicks?.[weekKey] || 0,
        monthClicks: linkData.monthlyClicks?.[monthKey] || 0,
        lastClicked: linkData.lastClicked?.toDate?.().toISOString() || linkData.lastClicked || null,
    })).sort((a, b) => b.totalClicks - a.totalClicks);

    // Process traffic sources
    const trafficSources = {};
     Object.keys(safeData).forEach(key => {
        const match = key.match(/^trafficSources\.([^.]+)\.(.+)$/);
        if (match) {
            const sourceKey = match[1];
            const property = match[2];
            if (!trafficSources[sourceKey]) trafficSources[sourceKey] = {};
            trafficSources[sourceKey][property] = safeData[key];
        }
    });

    return {
        totalViews: safeData.totalViews || 0,
        todayViews: dailyViews[today] || 0,
        totalClicks: safeData.totalClicks || 0,
        todayClicks: dailyClicks[today] || 0,
        dailyViews,
        dailyClicks,
        topLinks,
        trafficSources,
    };
}


/**
 * Fetch analytics data for a specific user from the 'Analytics' collection.
 * This now correctly fetches a single aggregated document per user.
 */
async function fetchUserAnalytics(userId, period = '30d') {
    try {
        console.log(`📊 Fetching single analytics document for user: ${userId}`);

        // ✅ CORRECT: Fetch a single document from the 'Analytics' collection by UID
        const analyticsRef = adminDb.collection('Analytics').doc(userId);
        const analyticsDoc = await analyticsRef.get();

        // If the user has no analytics document yet, return a default empty structure
        if (!analyticsDoc.exists) {
            console.warn(`🟡 No analytics document found for user: ${userId}. Returning empty state.`);
            return {
                totalViews: 0,
                todayViews: 0,
                totalClicks: 0,
                todayClicks: 0,
                dailyViews: {},
                dailyClicks: {},
                topLinks: [],
                trafficSources: {},
                period, // Still return period for context
            };
        }

        const rawData = analyticsDoc.data();
        
        // ✅ CORRECT: Use the robust processing logic from your other API
        const processedData = processAnalyticsData(rawData);
        
        // Add the period to the response for context on the frontend
        processedData.period = period;

        return processedData;

    } catch (error) {
        console.error(`Error fetching user analytics for UID ${userId}:`, error);
        throw error;
    }
}