// lib/services/serviceContact/client/services/AutoGroupService.js
// Client-side service for auto-generating contact groups.

"use client";
import { BaseContactService } from '../abstractions/BaseContactService';
import { ContactApiClient } from '../core/contactApiClient';

export class AutoGroupService extends BaseContactService {
  constructor() {
    super('AutoGroupService');
  }

  /**
   * Triggers the server to generate automatic groups based on provided options.
   * @param {object} options - Configuration for group generation.
   */
  async generateAutoGroups(options = {}) {
    console.log("📡 [Client Service] Sending request to /api/user/contacts/groups/auto-generate", { options });

    // ========================================================================
    // THE FIX IS HERE: We pass a longer timeout specifically for this request.
    // 30000ms = 30 seconds. You can increase it to 60000 if needed.
    // ========================================================================
    const result = await ContactApiClient.post('/api/user/contacts/groups/auto-generate', 
      { options }, 
      { timeout: 30000 } // Pass options object with timeout
    );
    // ========================================================================

    console.log("✅ [Client Service] Received response from API", result);

    // Invalidate the main groups cache so the UI re-fetches the new list
    this.invalidateCache(['group']);

    return result;
  }
// Complete the missing location grouping method for AutoGroupService

/**
 * Groups contacts by their approximate geographical location.
 */
static groupContactsByLocation(contacts, minGroupSize) {
  console.log(`  L 📍 [Location Grouping] Starting analysis of ${contacts.length} contacts. Minimum group size: ${minGroupSize}.`);
  const locationMap = {};

  contacts.forEach(contact => {
    if (contact.location?.latitude && contact.location?.longitude) {
      // Rounding to 1 decimal place (~11km) creates broader clusters.
      // Use more decimal places (e.g., * 100 / 100) for tighter clusters.
      const lat = Math.round(contact.location.latitude * 10) / 10;
      const lng = Math.round(contact.location.longitude * 10) / 10;
      const locationKey = `${lat},${lng}`;
      
      if (!locationMap[locationKey]) {
        locationMap[locationKey] = [];
      }
      locationMap[locationKey].push(contact.id);
      
      console.log(`    L ➡️ Clustering '${contact.name}' with location [${contact.location.latitude.toFixed(4)}, ${contact.location.longitude.toFixed(4)}] into key '${locationKey}'.`);
    } else {
      console.log(`    L ⏭️ Skipping '${contact.name}' - no location data.`);
    }
  });

  const finalGroups = Object.entries(locationMap)
    .filter(([key, contactIds]) => {
      const meetsCriteria = contactIds.length >= minGroupSize;
      if (meetsCriteria) {
        console.log(`    L ✅ Keeping location cluster '${key}' (size ${contactIds.length} >= ${minGroupSize}).`);
      } else {
        console.log(`    L 🗑️ Discarding location cluster '${key}' (size ${contactIds.length} < ${minGroupSize}).`);
      }
      return meetsCriteria;
    })
    .map(([location, contactIds], i) => {
      const groupName = `Location Group ${i + 1} (near ${location})`;
      console.log(`    L 📦 Creating final group '${groupName}' with ${contactIds.length} contacts.`);
      return {
        id: `auto_location_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: groupName,
        description: `Auto-generated group for contacts clustered near coordinates ${location}`,
        type: 'auto_location',
        contactIds,
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
        metadata: {
          locationCenter: location,
          autoGenerated: true,
          confidence: 'medium'
        }
      };
    });

  console.log(`  L 📍 [Location Grouping] Finished. Created ${finalGroups.length} valid groups.`);
  return finalGroups;
}
// Complete the missing events grouping method for AutoGroupService

/**
 * Groups contacts by events/special occasions (different from time-based grouping)
 * This looks for contacts added during special events, conferences, etc.
 */
static groupContactsByEvents(contacts, minGroupSize) {
  console.log(`  L 📅 [Event Grouping] Starting analysis of ${contacts.length} contacts. Minimum group size: ${minGroupSize}.`);
  
  const eventGroups = [];
  const processedContacts = new Set();

  // Group contacts that were added in rapid succession (likely from an event)
  const sortedContacts = contacts
    .filter(c => c.submittedAt)
    .map(c => ({
      ...c,
      timestamp: new Date(c.submittedAt).getTime()
    }))
    .sort((a, b) => a.timestamp - b.timestamp);

  let currentEventGroup = [];
  const eventThresholdHours = 4; // Contacts added within 4 hours might be from same event

  for (let i = 0; i < sortedContacts.length; i++) {
    const contact = sortedContacts[i];
    
    if (processedContacts.has(contact.id)) continue;

    // Start a new potential event group
    currentEventGroup = [contact];
    processedContacts.add(contact.id);

    // Look for contacts added soon after this one
    for (let j = i + 1; j < sortedContacts.length; j++) {
      const nextContact = sortedContacts[j];
      
      if (processedContacts.has(nextContact.id)) continue;

      const timeDiff = (nextContact.timestamp - contact.timestamp) / (1000 * 60 * 60); // hours
      
      if (timeDiff <= eventThresholdHours) {
        currentEventGroup.push(nextContact);
        processedContacts.add(nextContact.id);
        console.log(`    L ➡️ Adding '${nextContact.name}' to event group (${timeDiff.toFixed(1)}h after first contact).`);
      } else {
        break; // Contacts are sorted, so no point checking further
      }
    }

    // If we found enough contacts for an event group, create it
    if (currentEventGroup.length >= minGroupSize) {
      const firstContact = currentEventGroup[0];
      const lastContact = currentEventGroup[currentEventGroup.length - 1];
      const eventDate = new Date(firstContact.timestamp);
      const duration = (lastContact.timestamp - firstContact.timestamp) / (1000 * 60 * 60);

      // Determine event type based on patterns
      let eventType = 'event';
      let eventName = 'Event';
      
      if (duration <= 2) {
        eventType = 'rapid_networking';
        eventName = 'Networking Event';
      } else if (currentEventGroup.length >= 10) {
        eventType = 'conference';
        eventName = 'Conference';
      } else if (duration >= 6) {
        eventType = 'multi_day_event';
        eventName = 'Multi-day Event';
      }

      const eventGroup = {
        id: `auto_event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: `${eventName} - ${eventDate.toLocaleDateString()}`,
        description: `Auto-generated group for ${currentEventGroup.length} contacts from ${eventName.toLowerCase()}`,
        type: 'auto_event',
        contactIds: currentEventGroup.map(c => c.id),
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
        metadata: {
          eventDate: eventDate.toISOString(),
          eventType: eventType,
          duration: duration,
          contactCount: currentEventGroup.length,
          confidence: currentEventGroup.length >= 5 && duration <= 8 ? 'high' : 'medium',
          autoGenerated: true
        }
      };

      eventGroups.push(eventGroup);
      console.log(`    L 📦 Created event group '${eventGroup.name}' with ${currentEventGroup.length} contacts over ${duration.toFixed(1)} hours.`);
    } else {
      console.log(`    L 🗑️ Discarding potential event group (size ${currentEventGroup.length} < ${minGroupSize}).`);
      // Remove contacts from processed set since they weren't used
      currentEventGroup.forEach(c => processedContacts.delete(c.id));
    }
  }

  console.log(`  L 📅 [Event Grouping] Finished. Created ${eventGroups.length} valid event groups.`);
  return eventGroups;
}
}
