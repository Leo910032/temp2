// lib/services/serviceContact/client/services/AutoGroupService.js
// Client-side service for auto-generating contact groups.

"use client";
import { BaseContactService } from '../abstractions/BaseContactService';
import { ContactApiClient } from '../core/contactApiClient';

export class AutoGroupService extends BaseContactService {
  constructor() {
    super('AutoGroupService');
  }

    /**
   * Start AI group generation as a background job
   */
  async generateAutoGroupsAsync(options = {}) {
    console.log("üöÄ [Client Service] Starting background AI group generation", { options });

    const result = await ContactApiClient.post(
      '/api/user/contacts/groups/auto-generate-async',
      { options: options }, // <-- WRAP IT HERE
      { timeout: 10000 }
    );
    console.log("‚úÖ [Client Service] Background job started:", result);

    console.log("‚úÖ [Client Service] Background job started:", result);
    return result;
  }

   /**
   * Poll job status until completion
   */
  async pollJobStatus(jobId, onProgress = null, maxRetries = 60) {
    let retries = 0;
    
    while (retries < maxRetries) {
      try {
        const statusResult = await this.getJobStatus(jobId);
        const job = statusResult.job;
        
        // Call progress callback if provided
        if (onProgress) {
          onProgress(job);
        }
        
        // Check if job is complete
        if (job.status === 'completed') {
          this.invalidateCache(['group']); // Invalidate groups cache
          return { success: true, result: job.result };
        }
        
        if (job.status === 'failed') {
          throw new Error(job.error || 'Job failed');
        }
        
        // Wait before next poll
        await new Promise(resolve => setTimeout(resolve, 2000)); // Poll every 2 seconds
        retries++;
        
      } catch (error) {
        if (retries >= maxRetries - 1) {
          throw error;
        }
        await new Promise(resolve => setTimeout(resolve, 2000));
        retries++;
      }
    }
    
    throw new Error('Job polling timeout - job may still be running');
  }
/**
   * Check the status of a background job
   */
  async getJobStatus(jobId) {
    const result = await ContactApiClient.get(`/api/user/contacts/groups/job-status/${jobId}`);
    return result;
  }
// Complete the missing location grouping method for AutoGroupService

/**
 * Groups contacts by their approximate geographical location.
 */
static groupContactsByLocation(contacts, minGroupSize) {
  console.log(`  L üìç [Location Grouping] Starting analysis of ${contacts.length} contacts. Minimum group size: ${minGroupSize}.`);
  const locationMap = {};

  contacts.forEach(contact => {
    if (contact.location?.latitude && contact.location?.longitude) {
      // Rounding to 1 decimal place (~11km) creates broader clusters.
      // Use more decimal places (e.g., * 100 / 100) for tighter clusters.
      const lat = Math.round(contact.location.latitude * 10) / 10;
      const lng = Math.round(contact.location.longitude * 10) / 10;
      const locationKey = `${lat},${lng}`;
      
      if (!locationMap[locationKey]) {
        locationMap[locationKey] = [];
      }
      locationMap[locationKey].push(contact.id);
      
      console.log(`    L ‚û°Ô∏è Clustering '${contact.name}' with location [${contact.location.latitude.toFixed(4)}, ${contact.location.longitude.toFixed(4)}] into key '${locationKey}'.`);
    } else {
      console.log(`    L ‚è≠Ô∏è Skipping '${contact.name}' - no location data.`);
    }
  });

  const finalGroups = Object.entries(locationMap)
    .filter(([key, contactIds]) => {
      const meetsCriteria = contactIds.length >= minGroupSize;
      if (meetsCriteria) {
        console.log(`    L ‚úÖ Keeping location cluster '${key}' (size ${contactIds.length} >= ${minGroupSize}).`);
      } else {
        console.log(`    L üóëÔ∏è Discarding location cluster '${key}' (size ${contactIds.length} < ${minGroupSize}).`);
      }
      return meetsCriteria;
    })
    .map(([location, contactIds], i) => {
      const groupName = `Location Group ${i + 1} (near ${location})`;
      console.log(`    L üì¶ Creating final group '${groupName}' with ${contactIds.length} contacts.`);
      return {
        id: `auto_location_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: groupName,
        description: `Auto-generated group for contacts clustered near coordinates ${location}`,
        type: 'auto_location',
        contactIds,
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
        metadata: {
          locationCenter: location,
          autoGenerated: true,
          confidence: 'medium'
        }
      };
    });

  console.log(`  L üìç [Location Grouping] Finished. Created ${finalGroups.length} valid groups.`);
  return finalGroups;
}
// Complete the missing events grouping method for AutoGroupService

/**
 * Groups contacts by events/special occasions (different from time-based grouping)
 * This looks for contacts added during special events, conferences, etc.
 */
static groupContactsByEvents(contacts, minGroupSize) {
  console.log(`  L üìÖ [Event Grouping] Starting analysis of ${contacts.length} contacts. Minimum group size: ${minGroupSize}.`);
  
  const eventGroups = [];
  const processedContacts = new Set();

  // Group contacts that were added in rapid succession (likely from an event)
  const sortedContacts = contacts
    .filter(c => c.submittedAt)
    .map(c => ({
      ...c,
      timestamp: new Date(c.submittedAt).getTime()
    }))
    .sort((a, b) => a.timestamp - b.timestamp);

  let currentEventGroup = [];
  const eventThresholdHours = 4; // Contacts added within 4 hours might be from same event

  for (let i = 0; i < sortedContacts.length; i++) {
    const contact = sortedContacts[i];
    
    if (processedContacts.has(contact.id)) continue;

    // Start a new potential event group
    currentEventGroup = [contact];
    processedContacts.add(contact.id);

    // Look for contacts added soon after this one
    for (let j = i + 1; j < sortedContacts.length; j++) {
      const nextContact = sortedContacts[j];
      
      if (processedContacts.has(nextContact.id)) continue;

      const timeDiff = (nextContact.timestamp - contact.timestamp) / (1000 * 60 * 60); // hours
      
      if (timeDiff <= eventThresholdHours) {
        currentEventGroup.push(nextContact);
        processedContacts.add(nextContact.id);
        console.log(`    L ‚û°Ô∏è Adding '${nextContact.name}' to event group (${timeDiff.toFixed(1)}h after first contact).`);
      } else {
        break; // Contacts are sorted, so no point checking further
      }
    }

    // If we found enough contacts for an event group, create it
    if (currentEventGroup.length >= minGroupSize) {
      const firstContact = currentEventGroup[0];
      const lastContact = currentEventGroup[currentEventGroup.length - 1];
      const eventDate = new Date(firstContact.timestamp);
      const duration = (lastContact.timestamp - firstContact.timestamp) / (1000 * 60 * 60);

      // Determine event type based on patterns
      let eventType = 'event';
      let eventName = 'Event';
      
      if (duration <= 2) {
        eventType = 'rapid_networking';
        eventName = 'Networking Event';
      } else if (currentEventGroup.length >= 10) {
        eventType = 'conference';
        eventName = 'Conference';
      } else if (duration >= 6) {
        eventType = 'multi_day_event';
        eventName = 'Multi-day Event';
      }

      const eventGroup = {
        id: `auto_event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: `${eventName} - ${eventDate.toLocaleDateString()}`,
        description: `Auto-generated group for ${currentEventGroup.length} contacts from ${eventName.toLowerCase()}`,
        type: 'auto_event',
        contactIds: currentEventGroup.map(c => c.id),
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
        metadata: {
          eventDate: eventDate.toISOString(),
          eventType: eventType,
          duration: duration,
          contactCount: currentEventGroup.length,
          confidence: currentEventGroup.length >= 5 && duration <= 8 ? 'high' : 'medium',
          autoGenerated: true
        }
      };

      eventGroups.push(eventGroup);
      console.log(`    L üì¶ Created event group '${eventGroup.name}' with ${currentEventGroup.length} contacts over ${duration.toFixed(1)} hours.`);
    } else {
      console.log(`    L üóëÔ∏è Discarding potential event group (size ${currentEventGroup.length} < ${minGroupSize}).`);
      // Remove contacts from processed set since they weren't used
      currentEventGroup.forEach(c => processedContacts.delete(c.id));
    }
  }

  console.log(`  L üìÖ [Event Grouping] Finished. Created ${eventGroups.length} valid event groups.`);
  return eventGroups;
}
}
